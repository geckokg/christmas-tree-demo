<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Merry Christmas</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body, html {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: linear-gradient(180deg, #0a0e27 0%, #0f0a1a 50%, #000 100%);
      font-family: "Times New Roman", Times, serif;
    }
    #canvas {
      display: block;
      width: 100%;
      height: 100%;
    }
    #header {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      color: #c89568;
      font-size: 2.5rem;
      z-index: 5;
      pointer-events: none;
    }
    .header-item {
      opacity: 0;
      line-height: 1.5;
      margin: 1rem 0;
      transition: opacity 0.8s ease-in-out;
      letter-spacing: 2px;
    }
    .header-item.show {
      opacity: 1;
    }
    #mask {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.95);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 8rem;
      z-index: 10;
      cursor: pointer;
      animation: shake 0.4s ease-in-out infinite;
    }
    @keyframes shake {
      0% { transform: rotate(0deg); }
      25% { transform: rotate(-10deg); }
      50% { transform: rotate(0deg); }
      75% { transform: rotate(10deg); }
      100% { transform: rotate(0deg); }
    }
    #ui {
      position: fixed;
      bottom: 20px;
      left: 20px;
      z-index: 100;
      color: rgba(255, 255, 255, 0.8);
      font-size: 14px;
      font-family: monospace;
      background: rgba(0, 0, 0, 0.5);
      padding: 10px 15px;
      border-radius: 6px;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div id="header"></div>
  <div id="mask">❄️</div>
  <div id="ui">点击或触摸屏幕开始 / Click to start</div>

  <script>
    // ============ Canvas Setup ============
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let W = 0, H = 0;

    function resizeCanvas() {
      const dpr = window.devicePixelRatio || 1;
      W = canvas.width = window.innerWidth * dpr;
      H = canvas.height = window.innerHeight * dpr;
      canvas.style.width = window.innerWidth + 'px';
      canvas.style.height = window.innerHeight + 'px';
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // ============ Particle System ============
    const particles = [];
    const MAX_PARTICLES = 3000;

    function createParticle(x, y, vx, vy, life, size, color) {
      particles.push({
        x, y, vx, vy,
        life, maxLife: life,
        size, color,
        alpha: 1
      });
      if (particles.length > MAX_PARTICLES) particles.shift();
    }

    function spawnParticles(x, y, count = 30, spreadAngle = true) {
      const colors = ['#ffd60a', '#ff3b30', '#00bfff', '#7cfeff', '#ff69b4', '#ffffff'];
      for (let i = 0; i < count; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 3 + 1;
        const vx = Math.cos(angle) * speed;
        const vy = Math.sin(angle) * speed - Math.random() * 2;
        const life = Math.random() * 80 + 60;
        const size = Math.random() * 6 + 2;
        const color = colors[Math.floor(Math.random() * colors.length)];
        createParticle(x, y, vx, vy, life, size, color);
      }
    }

    function updateParticles(dt = 1) {
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.vy += 0.12; // gravity
        p.x += p.vx;
        p.y += p.vy;
        p.life -= dt;
        p.alpha = Math.max(0, p.life / p.maxLife);
        if (p.life <= 0) {
          particles.splice(i, 1);
        }
      }
    }

    function drawParticles() {
      ctx.globalCompositeOperation = 'lighter';
      particles.forEach(p => {
        const alpha = p.alpha;
        const r = parseInt(p.color.slice(1, 3), 16);
        const g = parseInt(p.color.slice(3, 5), 16);
        const b = parseInt(p.color.slice(5, 7), 16);
        
        // Glow
        const grad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size * 4);
        grad.addColorStop(0, `rgba(${r}, ${g}, ${b}, ${alpha * 0.8})`);
        grad.addColorStop(0.5, `rgba(${r}, ${g}, ${b}, ${alpha * 0.4})`);
        grad.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0)`);
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size * 3, 0, Math.PI * 2);
        ctx.fill();
      });
      ctx.globalCompositeOperation = 'source-over';
    }

    // ============ Christmas Tree (Particle-based) ============
    const treeParticles = [];
    const spiralParticles = [];
    let animationTime = 0;
    
    function initTreeParticles() {
      const cx = window.innerWidth / 2;
      const cy = window.innerHeight * 0.55;
      const baseWidth = Math.min(window.innerWidth * 0.8, 650); // Even larger tree
      const treeColors = ['#0fb254', '#0dd46a', '#09b84a', '#05cc2d'];
      
      // Generate tree particles in triangular shapes - MUCH MORE PARTICLES
      for (let layer = 0; layer < 5; layer++) {
        const h = 100 + layer * 70; // Even larger height
        const w = baseWidth * (1 - layer * 0.15);
        const x = cx;
        const y = cy - layer * 80; // More spacing between layers
        
        // Fill triangle with particles - 5x more particles
        const particlesPerLayer = 250 + layer * 150;
        for (let i = 0; i < particlesPerLayer; i++) {
          // Random point in triangle
          const r1 = Math.random();
          const r2 = Math.random();
          const sqrt_r1 = Math.sqrt(r1);
          
          const px = x + (1 - sqrt_r1) * (-w / 2) + sqrt_r1 * (r2 * w - w / 2);
          const py = y - h + sqrt_r1 * h;
          
          treeParticles.push({
            x: px,
            y: py,
            size: Math.random() * 3 + 1,
            color: treeColors[Math.floor(Math.random() * treeColors.length)],
            opacity: Math.random() * 0.6 + 0.4,
            twinkleSpeed: Math.random() * 0.03 + 0.01
          });
        }
      }
      
      // Trunk particles
      const trunkColor = '#8b5a3c';
      for (let i = 0; i < 80; i++) {
        treeParticles.push({
          x: cx - 35 + Math.random() * 70,
          y: cy + 150 + Math.random() * 100,
          size: Math.random() * 2 + 1,
          color: trunkColor,
          opacity: Math.random() * 0.5 + 0.5,
          twinkleSpeed: Math.random() * 0.02 + 0.005
        });
      }
      
      // Initialize spiral particles - yellow light wrapping around tree
      initSpiralParticles(cx, cy, baseWidth);
      
      // Initialize star at tree top
      initStarAtTop(cx, cy - 400);
    }
    
    function initStarAtTop(cx, cy) {
      const starColor = '#ffff00';
      const points = 5;
      const outerRadius = 40;
      const innerRadius = 16;
      
      // Create 5-pointed star with particles
      for (let i = 0; i < 120; i++) {
        // Random position on star outline
        const pointIndex = Math.random() * points;
        const isOuter = Math.random() > 0.4;
        const radius = isOuter ? outerRadius : innerRadius;
        const angle = (pointIndex * Math.PI * 2) / points;
        
        const x = cx + Math.cos(angle) * radius;
        const y = cy + Math.sin(angle) * radius;
        
        treeParticles.push({
          x,
          y,
          size: Math.random() * 2.5 + 1,
          color: starColor,
          opacity: Math.random() * 0.8 + 0.4,
          twinkleSpeed: Math.random() * 0.04 + 0.02
        });
      }
    }
    
    function initSpiralParticles(cx, cy, baseWidth) {
      const spiralColor = '#ffff99';
      const spiralCount = 200;
      
      for (let i = 0; i < spiralCount; i++) {
        const progress = i / spiralCount;
        const angle = progress * Math.PI * 6; // 3 full rotations
        const height = cy - 250 + progress * 400; // From top to bottom
        const radius = (baseWidth / 2) * (1 - Math.abs(progress * 2 - 1) * 0.3); // Spiral shape
        
        spiralParticles.push({
          angle,
          radius,
          height,
          progress,
          size: Math.random() * 2 + 1,
          color: spiralColor,
          opacity: 0.7,
          twinkleSpeed: Math.random() * 0.02 + 0.01,
          offsetX: (Math.random() - 0.5) * 30,
          offsetY: (Math.random() - 0.5) * 30
        });
      }
    }
    
    function drawSpiralParticles(cx, cy) {
      ctx.globalCompositeOperation = 'lighter';
      
      spiralParticles.forEach(p => {
        // Twinkle effect
        p.opacity += (Math.random() - 0.5) * p.twinkleSpeed;
        p.opacity = Math.max(0.3, Math.min(1, p.opacity));
        
        // Spiral position
        const currentAngle = p.angle + animationTime * 0.005;
        const x = cx + Math.cos(currentAngle) * p.radius + p.offsetX;
        const y = p.height + p.offsetY;
        
        // Yellow glow
        const grad = ctx.createRadialGradient(x, y, 0, x, y, p.size * 4);
        grad.addColorStop(0, `rgba(255, 255, 150, ${p.opacity})`);
        grad.addColorStop(0.6, `rgba(255, 255, 80, ${p.opacity * 0.5})`);
        grad.addColorStop(1, `rgba(255, 255, 50, 0)`);
        
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(x, y, p.size * 2.5, 0, Math.PI * 2);
        ctx.fill();
      });
      
      ctx.globalCompositeOperation = 'source-over';
    }
    
    function drawTreeParticles() {
      ctx.globalCompositeOperation = 'lighter';
      treeParticles.forEach(p => {
        // Twinkle effect
        p.opacity += (Math.random() - 0.5) * p.twinkleSpeed;
        p.opacity = Math.max(0.1, Math.min(1, p.opacity));
        
        const r = parseInt(p.color.slice(1, 3), 16);
        const g = parseInt(p.color.slice(3, 5), 16);
        const b = parseInt(p.color.slice(5, 7), 16);
        
        // Glow effect
        const grad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size * 4);
        grad.addColorStop(0, `rgba(${r}, ${g}, ${b}, ${p.opacity})`);
        grad.addColorStop(0.6, `rgba(${r}, ${g}, ${b}, ${p.opacity * 0.4})`);
        grad.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0)`);
        
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size * 2, 0, Math.PI * 2);
        ctx.fill();
      });
      ctx.globalCompositeOperation = 'source-over';
    }

    // ============ Background Stars (Expanding) ============
    const stars = [];
    const centerX = window.innerWidth / 2;
    const centerY = window.innerHeight / 2;
    let expansionPhase = 0;
    
    function initStars() {
      for (let i = 0; i < 500; i++) { // Increased from 200 to 500 stars
        const angle = Math.random() * Math.PI * 2;
        const distance = Math.random() * 300 + 50;
        stars.push({
          angle,
          distance,
          maxDistance: distance + Math.random() * 400,
          size: Math.random() * 2 + 0.5,
          opacity: Math.random() * 0.7 + 0.3,
          twinkleSpeed: Math.random() * 0.02 + 0.01,
          color: Math.random() > 0.5 ? '#ffff99' : '#ffffff'
        });
      }
    }

    function drawStars() {
      expansionPhase += 0.0005;
      const cyclophase = expansionPhase % 2; // Cycle from 0 to 2
      
      stars.forEach(s => {
        // Looping expanding effect - when it reaches max distance, reset to initial
        let currentDistance;
        if (cyclophase < 1) {
          // Expansion phase
          currentDistance = s.distance + (s.maxDistance - s.distance) * cyclophase;
        } else {
          // Reset phase - fade back to initial distance
          currentDistance = s.maxDistance - (s.maxDistance - s.distance) * (cyclophase - 1);
        }
        
        // Twinkle
        s.opacity += (Math.random() - 0.5) * s.twinkleSpeed;
        s.opacity = Math.max(0.1, Math.min(1, s.opacity));
        
        // Position in circular expansion
        const x = centerX + Math.cos(s.angle) * currentDistance;
        const y = centerY + Math.sin(s.angle) * currentDistance;
        
        // Draw with glow
        const grad = ctx.createRadialGradient(x, y, 0, x, y, s.size * 3);
        grad.addColorStop(0, `rgba(255, 255, 200, ${s.opacity})`);
        grad.addColorStop(1, `rgba(255, 255, 100, 0)`);
        
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(x, y, s.size * 2, 0, Math.PI * 2);
        ctx.fill();
      });
    }

    // ============ Animation Loop ============
    let isStarted = false;
    let lastTime = Date.now();
    
    // Initialize tree particles on page load
    initStars();
    initTreeParticles();

    function animate() {
      const now = Date.now();
      const dt = Math.min((now - lastTime) / 16.67, 2);
      lastTime = now;
      
      // Update animation time for spiral
      animationTime += dt;

      // Background
      ctx.fillStyle = 'rgba(10, 10, 40, 0.95)';
      ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);

      if (isStarted) {
        drawStars();
        drawTreeParticles();
        drawSpiralParticles(window.innerWidth / 2, window.innerHeight * 0.55);
        updateParticles(dt);
        drawParticles();
      } else {
        // Show tree even before animation starts
        drawStars();
        drawTreeParticles();
        drawSpiralParticles(window.innerWidth / 2, window.innerHeight * 0.55);
        drawSpiralParticles(window.innerWidth / 2, window.innerHeight * 0.6);
      }

      requestAnimationFrame(animate);
    }
    animate();

    // ============ Text Animation ============
    const myLabels = [
      '孙煦函',
      '欢乐豆要少玩',
    ];

    function initTextAnimation() {
      const headerEl = document.getElementById('header');
      myLabels.forEach((label, index) => {
        const p = document.createElement('p');
        p.className = 'header-item';
        p.innerHTML = label;
        headerEl.appendChild(p);
      });

      const labels = document.querySelectorAll('.header-item');
      labels.forEach((label, index) => {
        setTimeout(() => {
          label.classList.add('show');
        }, 800 * index);
      });
    }

    // ============ Audio ============
    const audioUrl = 'http://music.163.com/song/media/outer/url?id=1892513656.mp3';
    const audio = new Audio(audioUrl);
    audio.volume = 0.3;
    audio.loop = true;

    // ============ User Interaction ============
    const mask = document.getElementById('mask');
    let started = false;

    function startAnimation() {
      if (started) return;
      started = true;
      isStarted = true;

      // Try to play audio (may fail due to autoplay policy)
      audio.play().catch(err => console.log('Audio autoplay prevented:', err));

      // Hide mask
      mask.style.display = 'none';

      // Initialize text
      initTextAnimation();

      // Spawn initial particles
      spawnParticles(window.innerWidth / 2, window.innerHeight / 2, 50);
    }

    // Start on click or touch
    window.addEventListener('click', startAnimation);
    window.addEventListener('touchstart', startAnimation, { passive: true });

    // Also spawn particles on subsequent clicks
    window.addEventListener('click', (e) => {
      if (started) {
        spawnParticles(e.clientX, e.clientY, 40);
      }
    });

    window.addEventListener('touchmove', (e) => {
      if (started && e.touches.length > 0) {
        spawnParticles(e.touches[0].clientX, e.touches[0].clientY, 20);
      }
    }, { passive: true });
  </script>
</body>
</html>
